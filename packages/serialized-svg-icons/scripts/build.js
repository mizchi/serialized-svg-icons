const cheerio = require("cheerio");
const glob = require("glob-promise");
const path = require("path");
const fs = require("fs");
const { promisify } = require("util");
const camelcase = require("camelcase");
const findPackage = require("find-package");
const util = require("util");
const exec = util.promisify(require("child_process").exec);

const { icons } = require("../src/icons");

// file path
const rootDir = path.resolve(__dirname, "../");
const DIST = path.resolve(rootDir, ".");
const LIB = path.resolve(rootDir, "./lib");

// logic

async function getIconFiles(content) {
  return glob(content.files);
}
async function convertIconData(svg, multiColor) {
  const $svg = cheerio.load(svg, { xmlMode: true })("svg");

  // filter/convert attributes
  // 1. remove class attr
  // 2. convert to camelcase ex: fill-opacity => fillOpacity
  const attrConverter = (
    /** @type {{[key: string]: string}} */ attribs,
    /** @type string */ tagName
  ) =>
    attribs &&
    Object.keys(attribs)
      .filter(
        (name) =>
          ![
            "class",
            ...(tagName === "svg"
              ? ["xmlns", "xmlns:xlink", "xml:space", "width", "height"]
              : []), // if tagName is svg remove size attributes
          ].includes(name)
      )
      .reduce((obj, name) => {
        const newName = camelcase(name);
        switch (newName) {
          case "fill":
            if (attribs[name] === "none" || multiColor) {
              obj[newName] = attribs[name];
            }
            break;
          default:
            obj[newName] = attribs[name];
            break;
        }
        return obj;
      }, {});

  // convert to [ { tag: 'path', attr: { d: 'M436 160c6.6 ...', ... }, child: { ... } } ]
  const elementToTree = (/** @type {Cheerio} */ element) =>
    element
      .filter((_, e) => e.tagName && !["style"].includes(e.tagName))
      .map((_, e) => ({
        tag: e.tagName,
        attr: attrConverter(e.attribs, e.tagName),
        child:
          e.children && e.children.length
            ? elementToTree(cheerio(e.children))
            : undefined,
      }))
      .get();

  const tree = elementToTree($svg);
  return tree[0]; // like: [ { tag: 'path', attr: { d: 'M436 160c6.6 ...', ... }, child: { ... } } ]
}
function generateIconRow(icon, formattedName, iconData) {
  return `export const ${formattedName} = ${JSON.stringify(iconData)};\n`;
}

async function dirInit() {
  const ignore = (err) => {
    if (err.code === "EEXIST") return;
    throw err;
  };

  const mkdir = promisify(fs.mkdir);
  const writeFile = promisify(fs.writeFile);

  await mkdir(DIST).catch(ignore);
  await mkdir(LIB).catch(ignore);
  await mkdir(path.resolve(LIB, "esm")).catch(ignore);
  await mkdir(path.resolve(LIB, "cjs")).catch(ignore);

  const write = (filePath, str) =>
    writeFile(path.resolve(DIST, ...filePath), str, "utf8").catch(ignore);

  const initFiles = [
    "index.d.ts",
    "index.esm.js",
    "index.js",
    "all.js",
    "all.d.ts",
  ];

  const gitignore =
    [
      "# autogenerated",
      ...initFiles.map((s) => `/${s}`),
      ...icons.map((icon) => `/${icon.id}/`),
    ].join("\n") + "\nREADME.md\n\n";
  writeFile(path.resolve(DIST, ".gitignore"), gitignore);

  for (const icon of icons) {
    await mkdir(path.resolve(DIST, icon.id)).catch(ignore);
  }

  for (const file of initFiles) {
    await write([file], "// THIS FILE IS AUTO GENERATED\n");
  }
}
async function writeIconModule(icon) {
  const appendFile = promisify(fs.appendFile);
  const exists = new Set(); // for remove duplicate
  for (const content of icon.contents) {
    const files = await getIconFiles(content);
    for (const file of files) {
      const svgStr = await promisify(fs.readFile)(file, "utf8");
      const iconData = await convertIconData(svgStr, content.multiColor);
      const rawName = path.basename(file, path.extname(file));
      const pascalName = camelcase(rawName, { pascalCase: true });
      const name =
        (content.formatter && content.formatter(pascalName)) || pascalName;
      if (exists.has(name)) continue;
      exists.add(name);

      const modRes = generateIconRow(icon, name, iconData);
      await appendFile(path.resolve(DIST, icon.id, "index.js"), modRes, "utf8");
      exists.add(file);
    }
  }
}

async function writeIconsManifest() {
  const writeFile = promisify(fs.writeFile);
  const copyFile = promisify(fs.copyFile);

  const writeObj = icons.map((icon) => ({
    id: icon.id,
    name: icon.name,
    projectUrl: icon.projectUrl,
    license: icon.license,
    licenseUrl: icon.licenseUrl,
  }));
  const manifest = JSON.stringify(writeObj, null, 2);
  await writeFile(
    path.resolve(LIB, "es", "iconsManifest.js"),
    `export var IconsManifest = ${manifest}`,
    "utf8"
  );

  // await copyFile(
  //   "src/iconsManifest.d.ts",
  //   path.resolve(LIB, "esm", "iconsManifest.d.ts")
  // );
  // await copyFile(
  //   "src/iconsManifest.d.ts",
  //   path.resolve(LIB, "cjs", "iconsManifest.d.ts")
  // );
  await copyFile("src/package.json", path.resolve(LIB, "package.json"));
}

async function writeLicense() {
  const copyFile = promisify(fs.copyFile);
  const appendFile = promisify(fs.appendFile);

  const iconLicenses =
    icons
      .map((icon) =>
        [
          `${icon.name} - ${icon.projectUrl}`,
          `License: ${icon.license} ${icon.licenseUrl}`,
        ].join("\n")
      )
      .join("\n\n") + "\n";

  await copyFile(
    path.resolve(rootDir, "LICENSE_HEADER"),
    path.resolve(rootDir, "LICENSE")
  );
  await appendFile(path.resolve(rootDir, "LICENSE"), iconLicenses, "utf8");
}

async function writeEntryPoints() {
  const appendFile = promisify(fs.appendFile);
  const generateEntryCjs = function() {
    return `module.exports = require('./lib/cjs/index.js');`;
  };
  const generateEntryMjs = function(filename = "index.js") {
    return `import * as m from './lib/esm/${filename}'
export default m
    `;
  };
  await appendFile(path.resolve(DIST, "index.js"), generateEntryCjs(), "utf8");
  await appendFile(
    path.resolve(DIST, "index.esm.js"),
    generateEntryMjs(),
    "utf8"
  );
  await appendFile(
    path.resolve(DIST, "index.d.ts"),
    generateEntryMjs("index.d.ts"),
    "utf8"
  );
}

// async function writeIconVersions() {
//   const versions = [];

//   // searching for icon versions from package.json and git describe command
//   for (const icon of icons) {
//     const files = (
//       await Promise.all(icon.contents.map((content) => getIconFiles(content)))
//     ).flat();
//     const firstDir = path.dirname(files[0]);
//     const packageJson = findPackage(firstDir, true);
//     let gitVersion;
//     if (!packageJson.version) {
//       const { stdout } = await exec(
//         `cd ${firstDir} && git describe --tags || cd ${firstDir} && git rev-parse HEAD`
//       );
//       gitVersion = stdout.trim();
//       console.log("stdout", icon.id, stdout);
//     }
//     versions.push({
//       icon,
//       version: packageJson.version || gitVersion,
//     });
//   }

//   const versionsStr =
//     "Icon Library|License|Version\n" +
//     "---|---|---\n" +
//     versions
//       .map((v) =>
//         [
//           `[${v.icon.name}](${v.icon.projectUrl})`,
//           `[${v.icon.license}](${v.icon.licenseUrl})`,
//           v.version,
//         ].join("|")
//       )
//       .join("\n") +
//     "\n";

//   await fs.promises.writeFile(
//     path.resolve(rootDir, "VERSIONS"),
//     versionsStr,
//     "utf8"
//   );
// }

async function main() {
  try {
    await dirInit();
    await writeEntryPoints();
    await writeLicense();
    for (const icon of icons) {
      await writeIconModule(icon);
    }
    console.log("done");
  } catch (e) {
    console.error(e);
  }
}
main();
